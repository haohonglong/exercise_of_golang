<!DOCTYPE html><html><head><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-53605-21"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-53605-21');
          </script><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>File Upload REST API with Go and Amazon S3</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Practical tutorial to create a small REST API to upload files to Amazon S3 in Golang. Perfect for a microservice."/><meta name="next-head-count" content="6"/><link rel="preload" href="/_next/static/dU5p4h8CqmjB2C_JFQuti/pages/%5Bslug%5D.js" as="script"/><link rel="preload" href="/_next/static/dU5p4h8CqmjB2C_JFQuti/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-4b444dab214c6491079c.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.921669d6706eeb20080a.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-6e6e334c1a3c61df2d4f.js" as="script"/><link rel="preload" href="/_next/static/chunks/styles.19cd142641676dafa9ae.js" as="script"/><link rel="stylesheet" href="/_next/static/css/styles.a7c96b16.chunk.css"/></head><body><div id="__next"><div class="font-sans p-8 leading-normal text-lg antialiased text-gray-900"><header class="mb-8 flex items-center"><div class="flex-1"></div><div class="text-center leading-none font-black"><a class="inline-block p-1 rounded bg-red-600 text-white hover:text-red-600 hover:bg-white" href="/"><div>ニ</div><div>コ</div><div>三</div></a></div><nav class="flex-1 flex justify-end text-xl font-semibold"><a class="ml-8 text-gray-600 hover:text-red-600 hover:underline" href="/about"><span class="hover:text-gray-900">About</span></a></nav></header><div class="max-w-2xl mx-auto markdown"><h1>File Upload REST API with Go and Amazon S3</h1><p>Among the things I dislike doing in web development, I think file upload is in the Top 3. It&#x27;s not hard and lots of libraries in your favorite language will help you to that. But there are always some small annoyances to store files on servers. Now I deploy my code to Heroku, put my files on S3 and it&#x27;s done. Far easier! The other day, I wanted to create a small HTTP service to upload files on S3 in Go but there&#x27;s no packaged solution to do that, so I thought I would write an article about it. Here&#x27;s how I did it.</p><h2>Requirements</h2><p>First, we need a package to interact with Amazon Web Services. For this article, I chose to use <a href="https://github.com/mitchellh/goamz">mitchellh/goamz</a> from Mitchell Hashimoto (creator of Vagrant and HashiCorp). It&#x27;s a fork of <a href="https://github.com/goamz/goamz">goamz/goamz</a>. There is also an <a href="https://github.com/awslabs/aws-sdk-go">&quot;official&quot; package</a> developed by Stripe with Amazon recently making it official, but it&#x27;s marked as &quot;incredibly experimental&quot; so I prefer to use the more stable one.</p><p>For the HTTP part, I decided to use <a href="https://github.com/nmerouze/stack">stack</a>, my own framework.</p><pre>go get -u github.com/mitchellh/goamz<br/>go get -u github.com/nmerouze/stack</pre><h2>Upload Files on S3</h2><p>I am not going to use a real S3 bucket to write my code, so this article will be written as an example of how to write web services in TDD with Go. The first action would be to upload a file on S3. The test will start by initializing a fake S3 server and create the bucket:</p><pre>package upload_test<br/><br/>import (<br/>  &quot;testing&quot;<br/><br/>  &quot;github.com/mitchellh/goamz/aws&quot;<br/>  &quot;github.com/mitchellh/goamz/s3&quot;<br/>  &quot;github.com/mitchellh/goamz/s3/s3test&quot;<br/>)<br/><br/>func startServer() (*s3test.Server, *s3.Bucket) {<br/>  testServer, _ := s3test.NewServer(new(s3test.Config)) // Fake server<br/>  auth := aws.Auth{&quot;abc&quot;, &quot;123&quot;, &quot;&quot;} // Fake credentials<br/>  conn := s3.New(auth, aws.Region{Name: &quot;faux-region-1&quot;, S3Endpoint: testServer.URL(), S3LocationConstraint: true}) // Needs to be true when testing<br/>  bucket := conn.Bucket(&quot;foobar.com&quot;) // Fake bucket<br/>  bucket.PutBucket(s3.Private) // Bucket creation<br/>  return testServer, bucket<br/>}<br/><br/>func TestPut(t *testing.T) {<br/>  s, b := startServer()<br/>  defer s.Quit() // Quit the fake server when the test is done<br/>}</pre><p>As we will have to start the server for each test, we can directly put the code in a function. Then we make a fake request to our web service.</p><pre>func TestPut(t *testing.T) {<br/>  // ...<br/>  w := httptest.NewRecorder()<br/>  r, _ := http.NewRequest(&quot;PUT&quot;, &quot;/files/foo.txt&quot;, bytes.NewBufferString(&quot;foobar&quot;)) // We send a file named foo.txt with the content &quot;foobar&quot;<br/>  r.Header.Set(&quot;Content-Type&quot;, &quot;text/plain&quot;)<br/>  upload.Service(b).ServeHTTP(w, r) // &quot;upload&quot; is the name of our package<br/>}</pre><p>Then we need to see if things go well. The status must be 200 (OK), we want to set the Location header to the URL of the file on S3, we want to check if the file has been created and finally to see if the JSON body is correct.</p><pre>func TestPut(t *testing.T) {<br/>  // ...<br/>  expCode := 200<br/>  if w.Code != expCode {<br/>    t.Fatalf(&quot;Response status expected: %#v, got: %#v&quot;, expCode, w.Code)<br/>  }<br/><br/>  expLoc := b.URL(&quot;/foo.txt&quot;) // We get the full URL of the file stored in the bucket<br/>  if w.Header().Get(&quot;Location&quot;) != expLoc {<br/>    t.Fatalf(&quot;Response Location header expected: %#v, got: %#v&quot;, expLoc, w.Header().Get(&quot;Location&quot;))<br/>  }<br/><br/>  expBody := fmt.Sprintf(`{&quot;url&quot;:&quot;%s&quot;}`, expLoc)<br/>  if w.Body.String() != expBody {<br/>    t.Fatalf(&quot;Response body expected: %#v, got: %#v&quot;, expBody, w.Body.String())<br/>  }<br/><br/>  data, _ := b.Get(&quot;/foo.txt&quot;) // We get the file stored in the bucket<br/>  if string(data) != &quot;foobar&quot; {<br/>    t.Fatalf(&quot;Stored file content expected: %#v, got: %#v&quot;, &quot;foobar&quot;, string(data))<br/>  }<br/>}</pre><p>Now we can see our test fail with `go test ./.`</p><pre># github.com/nmerouze/stack-examples/upload_test ./upload_test.go:32: undefined: upload.Service FAIL  github.com/nmerouze/stack-examples/upload [build failed]</pre><p>So now we know what to expect, let&#x27;s make our first action. First, we define the router of our service:</p><pre>package upload<br/><br/>import (<br/>  &quot;net/http&quot;<br/><br/>  &quot;github.com/mitchellh/goamz/s3&quot;<br/>  &quot;github.com/nmerouze/stack/mux&quot;<br/>)<br/><br/>func Service(bucket *s3.Bucket) http.Handler {<br/>  m := mux.New()<br/>  return m<br/>}</pre><p>Let&#x27;s run our test again.</p><pre>--- FAIL: TestPut (0.00 seconds)<br/>  upload_test.go:36: Response status expected: 200, got: 404<br/>FAIL<br/>FAIL  github.com/nmerouze/stack-examples/upload 0.017s</pre><p>Great our first expectation is visible, let&#x27;s add the code for that:</p><pre>package upload<br/><br/>import (<br/>  &quot;net/http&quot;<br/><br/>  &quot;github.com/mitchellh/goamz/s3&quot;<br/>  &quot;github.com/nmerouze/stack/mux&quot;<br/>)<br/><br/>// All our handlers are methods of this struct so they are able to access the bucket.<br/>type appContext struct {<br/>  bucket *s3.Bucket<br/>}<br/><br/>func (c *appContext) upsertFile(w http.ResponseWriter, r *http.Request) {<br/>}<br/><br/>func Service(bucket *s3.Bucket) http.Handler {<br/>  c := &amp;appContext{bucket}<br/>  m := mux.New()<br/>  m.Put(&quot;/files/*path&quot;).ThenFunc(c.upsertFile)<br/>  return m<br/>}</pre><p>What does our test say?</p><pre>--- FAIL: TestPut (0.00 seconds)   upload_test.go:41: Response Location header expected: &quot;http://127.0.0.1:52356/foobar.com/foo.txt&quot;, got: &quot;&quot; FAIL FAIL  github.com/nmerouze/stack-examples/upload 0.016s</pre><p>Ok, we pass the status expectation. Now we need to write our handler. It will read the request body (the content of the file), get the URL path (path of the file) and put it on S3. Then we write the Location header and the response body.</p><pre>func (c *appContext) upsertFile(w http.ResponseWriter, r *http.Request) {<br/>  content, _ := ioutil.ReadAll(r.Body)<br/>  path := mux.Params(r).ByName(&quot;path&quot;)<br/>  c.bucket.Put(path, content, r.Header.Get(&quot;Content-Type&quot;), s3.PublicRead)<br/>  url := c.bucket.URL(path)<br/>  w.Header().Set(&quot;Location&quot;, url)<br/>  w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)<br/>  fmt.Fprintf(w, `{&quot;url&quot;:&quot;%s&quot;}`, url)<br/>}</pre><p>The test should pass:</p><pre>ok    github.com/nmerouze/upload  0.022s</pre><p>I used `ioutil.ReadAll()` to read the body, but a better implementation would be to use `io.Copy()`. For more information, <a href="http://matt.aimonetti.net/posts/2013/07/01/golang-multipart-file-upload-example/">read this article</a>.</p><p>There we have our upload action. We didn&#x27;t handle the errors at all. Most of the possible errors aren&#x27;t really testable. Though one thing will trigger a panic: no request body. In this case `ioutil.ReadAll()` will panic and we need to handle this case. The test will be similar to the previous one but we will just put nil instead of the body and change the expectations a bit:</p><pre>func TestPutBodyNil(t *testing.T) {<br/>  s, b := startServer()<br/>  defer s.Quit()<br/><br/>  w := httptest.NewRecorder()<br/>  r, _ := http.NewRequest(&quot;PUT&quot;, &quot;/files/foo.txt&quot;, nil)<br/>  upload.Service(b).ServeHTTP(w, r)<br/><br/>  expCode := 400<br/>  if w.Code != expCode {<br/>    t.Fatalf(&quot;Response status expected: %#v, got: %#v&quot;, expCode, w.Code)<br/>  }<br/><br/>  expBody := &quot;Body must be set\n&quot;<br/>  if w.Body.String() != expBody {<br/>    t.Fatalf(&quot;Response body expected: %#v, got: %#v&quot;, expBody, w.Body.String())<br/>  }<br/>}</pre><p>If we run the test, the code will panic showing we have a problem. So let&#x27;s return an error if there is no request body:</p><pre>func (c *appContext) upsertFile(w http.ResponseWriter, r *http.Request) {<br/>  if r.Body == nil {<br/>    http.Error(w, &quot;Body must be set&quot;, http.StatusBadRequest)<br/>    return<br/>  }<br/><br/>  // ...<br/>}</pre><p>We check if the body is nil at the top of the handler and return an error if it is. The test will pass and we will have handle the main problem. There are other errors but I didn&#x27;t find any simple solution to reproduce them in tests because most values passed to them will not result in errors. We could test them with mocking and stubbing but it would require more complexity in the code and for the purpose of this article, I don&#x27;t think it would be useful. Let&#x27;s handle the errors in the code anyway:</p><pre>func (c *appContext) upsertFile(w http.ResponseWriter, r *http.Request) {<br/>  if r.Body == nil {<br/>    http.Error(w, &quot;Body must be set&quot;, http.StatusBadRequest)<br/>    return<br/>  }<br/><br/>  // I didn&#x27;t find what kind of body would give an error, but let&#x27;s write the error code anyway.<br/>  content, err := ioutil.ReadAll(r.Body)<br/>  if err != nil {<br/>    http.Error(w, err.Error(), http.StatusBadRequest)<br/>    return<br/>  }<br/><br/>  // If S3 has any problem with our request, it will return an error. It could also be a 500 error if S3 itself has a problem.<br/>  path := mux.Params(r).ByName(&quot;path&quot;)<br/>  err = c.bucket.Put(path, content, r.Header.Get(&quot;Content-Type&quot;), s3.PublicRead)<br/>  if err != nil {<br/>    http.Error(w, err.Error(), http.StatusBadRequest)<br/>    return<br/>  }<br/><br/>  url := c.bucket.URL(path)<br/>  w.Header().Set(&quot;Location&quot;, url)<br/>  w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)<br/>  fmt.Fprintf(w, `{&quot;url&quot;:&quot;%s&quot;}`, url)<br/>}</pre><p>Every possible error is handled. Our endpoint is now complete. <a href="https://github.com/nmerouze/stack-examples/tree/master/upload">The code is on github</a>.</p><h2>Get and Delete files</h2><p>I am not going to write anything in the article about these endpoints because there are trivial, but <a href="https://github.com/nmerouze/stack-examples/tree/master/upload">you can find them on github</a>.</p><h2>Binary</h2><p>Now we have our package but to run the program we need to create a binary (a file with the main function). The function will initialize a connection to S3 and pass a bucket to the app. I create a main.go file in cmd directory in my package to do so.</p><pre>package main<br/><br/>import (<br/>  &quot;net/http&quot;<br/><br/>  &quot;../../upload&quot;<br/>  &quot;github.com/mitchellh/goamz/aws&quot;<br/>  &quot;github.com/mitchellh/goamz/s3&quot;<br/>)<br/><br/>func main() {<br/>  auth, err := aws.EnvAuth()<br/>  if err != nil {<br/>    panic(err)<br/>  }<br/><br/>  server := s3.New(auth, aws.USEast)<br/>  b := server.Bucket(&quot;foobar.com&quot;)<br/>  h := upload.Service(b)<br/>  http.ListenAndServe(&quot;:8080&quot;, h)<br/>}</pre><p>goamz has a neat function to read the credentials from the environment, pretty useful! Replace foobar.com with an existing bucket in your S3 account and you&#x27;re done with this file.</p><p>To run this code on a development machine, we are going to create a .env at the root file with our credentials of the package.</p><pre>AWS_ACCESS_KEY_ID=123 AWS_SECRET_ACCESS_KEY=abc</pre><p>And a Makefile to automate the command:</p><pre>run:<br/>  env $$(cat .env) go run cmd/main.go</pre><p>Here we have a web service that can run with the command `make run` and upload files on our S3 account. When it runs, just test it with curl.</p><pre>curl -d &#x27;foobar&#x27; -X PUT -H &#x27;Content-Type: text/plain&#x27; http://localhost:8080/files/foo.txt</pre><p>foo.txt should be in the selected bucket with the content foobar.</p><h2>Conclusion</h2><p>Uploading files to S3 is very concise. Building a web service to do the job is also very straightforward. But this article does not deal with security. I plan to write an article about authentication and JSON Web Tokens. Something like a middleware that can be added to the routes of this service to secure the endpoints.</p></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{"doc":{"id":"Xal_GRIAACEAt5ML","uid":"file-upload-web-service-golang-s3-aws","type":"post","href":"https://nicolasmerouze.cdn.prismic.io/api/v2/documents/search?ref=XaniUxIAACAAuUkg\u0026q=%5B%5B%3Ad+%3D+at%28document.id%2C+%22Xal_GRIAACEAt5ML%22%29+%5D%5D","tags":[],"first_publication_date":"2019-10-18T09:06:10+0000","last_publication_date":"2019-10-18T15:41:35+0000","slugs":["file-upload-rest-api-with-go-and-amazon-s3","fileuploadrestapiwithgoandamazons3"],"linked_documents":[],"lang":"en-us","alternate_languages":[],"data":{"title":"File Upload REST API with Go and Amazon S3","description":"Practical tutorial to create a small REST API to upload files to Amazon S3 in Golang. Perfect for a microservice.","created":"2015-03-04","body":[{"slice_type":"text","slice_label":null,"items":[{}],"primary":{"text":[{"type":"heading1","text":"File Upload REST API with Go and Amazon S3","spans":[]},{"type":"paragraph","text":"Among the things I dislike doing in web development, I think file upload is in the Top 3. It's not hard and lots of libraries in your favorite language will help you to that. But there are always some small annoyances to store files on servers. Now I deploy my code to Heroku, put my files on S3 and it's done. Far easier! The other day, I wanted to create a small HTTP service to upload files on S3 in Go but there's no packaged solution to do that, so I thought I would write an article about it. Here's how I did it.","spans":[]},{"type":"heading2","text":"Requirements","spans":[]},{"type":"paragraph","text":"First, we need a package to interact with Amazon Web Services. For this article, I chose to use mitchellh/goamz from Mitchell Hashimoto (creator of Vagrant and HashiCorp). It's a fork of goamz/goamz. There is also an \"official\" package developed by Stripe with Amazon recently making it official, but it's marked as \"incredibly experimental\" so I prefer to use the more stable one.","spans":[{"start":96,"end":111,"type":"hyperlink","data":{"link_type":"Web","url":"https://github.com/mitchellh/goamz"}},{"start":187,"end":198,"type":"hyperlink","data":{"link_type":"Web","url":"https://github.com/goamz/goamz"}},{"start":217,"end":235,"type":"hyperlink","data":{"link_type":"Web","url":"https://github.com/awslabs/aws-sdk-go"}}]},{"type":"paragraph","text":"For the HTTP part, I decided to use stack, my own framework.","spans":[{"start":36,"end":41,"type":"hyperlink","data":{"link_type":"Web","url":"https://github.com/nmerouze/stack"}}]},{"type":"preformatted","text":"go get -u github.com/mitchellh/goamz\ngo get -u github.com/nmerouze/stack","spans":[]},{"type":"heading2","text":"Upload Files on S3","spans":[]},{"type":"paragraph","text":"I am not going to use a real S3 bucket to write my code, so this article will be written as an example of how to write web services in TDD with Go. The first action would be to upload a file on S3. The test will start by initializing a fake S3 server and create the bucket:","spans":[]},{"type":"preformatted","text":"package upload_test\n\nimport (\n  \"testing\"\n\n  \"github.com/mitchellh/goamz/aws\"\n  \"github.com/mitchellh/goamz/s3\"\n  \"github.com/mitchellh/goamz/s3/s3test\"\n)\n\nfunc startServer() (*s3test.Server, *s3.Bucket) {\n  testServer, _ := s3test.NewServer(new(s3test.Config)) // Fake server\n  auth := aws.Auth{\"abc\", \"123\", \"\"} // Fake credentials\n  conn := s3.New(auth, aws.Region{Name: \"faux-region-1\", S3Endpoint: testServer.URL(), S3LocationConstraint: true}) // Needs to be true when testing\n  bucket := conn.Bucket(\"foobar.com\") // Fake bucket\n  bucket.PutBucket(s3.Private) // Bucket creation\n  return testServer, bucket\n}\n\nfunc TestPut(t *testing.T) {\n  s, b := startServer()\n  defer s.Quit() // Quit the fake server when the test is done\n}","spans":[]},{"type":"paragraph","text":"As we will have to start the server for each test, we can directly put the code in a function. Then we make a fake request to our web service.","spans":[]},{"type":"preformatted","text":"func TestPut(t *testing.T) {\n  // ...\n  w := httptest.NewRecorder()\n  r, _ := http.NewRequest(\"PUT\", \"/files/foo.txt\", bytes.NewBufferString(\"foobar\")) // We send a file named foo.txt with the content \"foobar\"\n  r.Header.Set(\"Content-Type\", \"text/plain\")\n  upload.Service(b).ServeHTTP(w, r) // \"upload\" is the name of our package\n}","spans":[]},{"type":"paragraph","text":"Then we need to see if things go well. The status must be 200 (OK), we want to set the Location header to the URL of the file on S3, we want to check if the file has been created and finally to see if the JSON body is correct.","spans":[]},{"type":"preformatted","text":"func TestPut(t *testing.T) {\n  // ...\n  expCode := 200\n  if w.Code != expCode {\n    t.Fatalf(\"Response status expected: %#v, got: %#v\", expCode, w.Code)\n  }\n\n  expLoc := b.URL(\"/foo.txt\") // We get the full URL of the file stored in the bucket\n  if w.Header().Get(\"Location\") != expLoc {\n    t.Fatalf(\"Response Location header expected: %#v, got: %#v\", expLoc, w.Header().Get(\"Location\"))\n  }\n\n  expBody := fmt.Sprintf(`{\"url\":\"%s\"}`, expLoc)\n  if w.Body.String() != expBody {\n    t.Fatalf(\"Response body expected: %#v, got: %#v\", expBody, w.Body.String())\n  }\n\n  data, _ := b.Get(\"/foo.txt\") // We get the file stored in the bucket\n  if string(data) != \"foobar\" {\n    t.Fatalf(\"Stored file content expected: %#v, got: %#v\", \"foobar\", string(data))\n  }\n}","spans":[]},{"type":"paragraph","text":"Now we can see our test fail with `go test ./.`","spans":[]},{"type":"preformatted","text":"# github.com/nmerouze/stack-examples/upload_test ./upload_test.go:32: undefined: upload.Service FAIL  github.com/nmerouze/stack-examples/upload [build failed]","spans":[]},{"type":"paragraph","text":"So now we know what to expect, let's make our first action. First, we define the router of our service:","spans":[]},{"type":"preformatted","text":"package upload\n\nimport (\n  \"net/http\"\n\n  \"github.com/mitchellh/goamz/s3\"\n  \"github.com/nmerouze/stack/mux\"\n)\n\nfunc Service(bucket *s3.Bucket) http.Handler {\n  m := mux.New()\n  return m\n}","spans":[]},{"type":"paragraph","text":"Let's run our test again.","spans":[]},{"type":"preformatted","text":"--- FAIL: TestPut (0.00 seconds)\n  upload_test.go:36: Response status expected: 200, got: 404\nFAIL\nFAIL  github.com/nmerouze/stack-examples/upload 0.017s","spans":[]},{"type":"paragraph","text":"Great our first expectation is visible, let's add the code for that:","spans":[]},{"type":"preformatted","text":"package upload\n\nimport (\n  \"net/http\"\n\n  \"github.com/mitchellh/goamz/s3\"\n  \"github.com/nmerouze/stack/mux\"\n)\n\n// All our handlers are methods of this struct so they are able to access the bucket.\ntype appContext struct {\n  bucket *s3.Bucket\n}\n\nfunc (c *appContext) upsertFile(w http.ResponseWriter, r *http.Request) {\n}\n\nfunc Service(bucket *s3.Bucket) http.Handler {\n  c := \u0026appContext{bucket}\n  m := mux.New()\n  m.Put(\"/files/*path\").ThenFunc(c.upsertFile)\n  return m\n}","spans":[]},{"type":"paragraph","text":"What does our test say?","spans":[]},{"type":"preformatted","text":"--- FAIL: TestPut (0.00 seconds)   upload_test.go:41: Response Location header expected: \"http://127.0.0.1:52356/foobar.com/foo.txt\", got: \"\" FAIL FAIL  github.com/nmerouze/stack-examples/upload 0.016s","spans":[]},{"type":"paragraph","text":"Ok, we pass the status expectation. Now we need to write our handler. It will read the request body (the content of the file), get the URL path (path of the file) and put it on S3. Then we write the Location header and the response body.","spans":[]},{"type":"preformatted","text":"func (c *appContext) upsertFile(w http.ResponseWriter, r *http.Request) {\n  content, _ := ioutil.ReadAll(r.Body)\n  path := mux.Params(r).ByName(\"path\")\n  c.bucket.Put(path, content, r.Header.Get(\"Content-Type\"), s3.PublicRead)\n  url := c.bucket.URL(path)\n  w.Header().Set(\"Location\", url)\n  w.Header().Set(\"Content-Type\", \"application/json\")\n  fmt.Fprintf(w, `{\"url\":\"%s\"}`, url)\n}","spans":[]},{"type":"paragraph","text":"The test should pass:","spans":[]},{"type":"preformatted","text":"ok    github.com/nmerouze/upload  0.022s","spans":[]},{"type":"paragraph","text":"I used `ioutil.ReadAll()` to read the body, but a better implementation would be to use `io.Copy()`. For more information, read this article.","spans":[{"start":123,"end":140,"type":"hyperlink","data":{"link_type":"Web","url":"http://matt.aimonetti.net/posts/2013/07/01/golang-multipart-file-upload-example/"}}]},{"type":"paragraph","text":"There we have our upload action. We didn't handle the errors at all. Most of the possible errors aren't really testable. Though one thing will trigger a panic: no request body. In this case `ioutil.ReadAll()` will panic and we need to handle this case. The test will be similar to the previous one but we will just put nil instead of the body and change the expectations a bit:","spans":[]},{"type":"preformatted","text":"func TestPutBodyNil(t *testing.T) {\n  s, b := startServer()\n  defer s.Quit()\n\n  w := httptest.NewRecorder()\n  r, _ := http.NewRequest(\"PUT\", \"/files/foo.txt\", nil)\n  upload.Service(b).ServeHTTP(w, r)\n\n  expCode := 400\n  if w.Code != expCode {\n    t.Fatalf(\"Response status expected: %#v, got: %#v\", expCode, w.Code)\n  }\n\n  expBody := \"Body must be set\\n\"\n  if w.Body.String() != expBody {\n    t.Fatalf(\"Response body expected: %#v, got: %#v\", expBody, w.Body.String())\n  }\n}","spans":[]},{"type":"paragraph","text":"If we run the test, the code will panic showing we have a problem. So let's return an error if there is no request body:","spans":[]},{"type":"preformatted","text":"func (c *appContext) upsertFile(w http.ResponseWriter, r *http.Request) {\n  if r.Body == nil {\n    http.Error(w, \"Body must be set\", http.StatusBadRequest)\n    return\n  }\n\n  // ...\n}","spans":[]},{"type":"paragraph","text":"We check if the body is nil at the top of the handler and return an error if it is. The test will pass and we will have handle the main problem. There are other errors but I didn't find any simple solution to reproduce them in tests because most values passed to them will not result in errors. We could test them with mocking and stubbing but it would require more complexity in the code and for the purpose of this article, I don't think it would be useful. Let's handle the errors in the code anyway:","spans":[]},{"type":"preformatted","text":"func (c *appContext) upsertFile(w http.ResponseWriter, r *http.Request) {\n  if r.Body == nil {\n    http.Error(w, \"Body must be set\", http.StatusBadRequest)\n    return\n  }\n\n  // I didn't find what kind of body would give an error, but let's write the error code anyway.\n  content, err := ioutil.ReadAll(r.Body)\n  if err != nil {\n    http.Error(w, err.Error(), http.StatusBadRequest)\n    return\n  }\n\n  // If S3 has any problem with our request, it will return an error. It could also be a 500 error if S3 itself has a problem.\n  path := mux.Params(r).ByName(\"path\")\n  err = c.bucket.Put(path, content, r.Header.Get(\"Content-Type\"), s3.PublicRead)\n  if err != nil {\n    http.Error(w, err.Error(), http.StatusBadRequest)\n    return\n  }\n\n  url := c.bucket.URL(path)\n  w.Header().Set(\"Location\", url)\n  w.Header().Set(\"Content-Type\", \"application/json\")\n  fmt.Fprintf(w, `{\"url\":\"%s\"}`, url)\n}","spans":[]},{"type":"paragraph","text":"Every possible error is handled. Our endpoint is now complete. The code is on github.","spans":[{"start":63,"end":84,"type":"hyperlink","data":{"link_type":"Web","url":"https://github.com/nmerouze/stack-examples/tree/master/upload"}}]},{"type":"heading2","text":"Get and Delete files","spans":[]},{"type":"paragraph","text":"I am not going to write anything in the article about these endpoints because there are trivial, but you can find them on github.","spans":[{"start":101,"end":128,"type":"hyperlink","data":{"link_type":"Web","url":"https://github.com/nmerouze/stack-examples/tree/master/upload"}}]},{"type":"heading2","text":"Binary","spans":[]},{"type":"paragraph","text":"Now we have our package but to run the program we need to create a binary (a file with the main function). The function will initialize a connection to S3 and pass a bucket to the app. I create a main.go file in cmd directory in my package to do so.","spans":[]},{"type":"preformatted","text":"package main\n\nimport (\n  \"net/http\"\n\n  \"../../upload\"\n  \"github.com/mitchellh/goamz/aws\"\n  \"github.com/mitchellh/goamz/s3\"\n)\n\nfunc main() {\n  auth, err := aws.EnvAuth()\n  if err != nil {\n    panic(err)\n  }\n\n  server := s3.New(auth, aws.USEast)\n  b := server.Bucket(\"foobar.com\")\n  h := upload.Service(b)\n  http.ListenAndServe(\":8080\", h)\n}","spans":[]},{"type":"paragraph","text":"goamz has a neat function to read the credentials from the environment, pretty useful! Replace foobar.com with an existing bucket in your S3 account and you're done with this file.","spans":[]},{"type":"paragraph","text":"To run this code on a development machine, we are going to create a .env at the root file with our credentials of the package.","spans":[]},{"type":"preformatted","text":"AWS_ACCESS_KEY_ID=123 AWS_SECRET_ACCESS_KEY=abc","spans":[]},{"type":"paragraph","text":"And a Makefile to automate the command:","spans":[]},{"type":"preformatted","text":"run:\n  env $$(cat .env) go run cmd/main.go","spans":[]},{"type":"paragraph","text":"Here we have a web service that can run with the command `make run` and upload files on our S3 account. When it runs, just test it with curl.","spans":[]},{"type":"preformatted","text":"curl -d 'foobar' -X PUT -H 'Content-Type: text/plain' http://localhost:8080/files/foo.txt","spans":[]},{"type":"paragraph","text":"foo.txt should be in the selected bucket with the content foobar.","spans":[]},{"type":"heading2","text":"Conclusion","spans":[]},{"type":"paragraph","text":"Uploading files to S3 is very concise. Building a web service to do the job is also very straightforward. But this article does not deal with security. I plan to write an article about authentication and JSON Web Tokens. Something like a middleware that can be added to the routes of this service to secure the endpoints.","spans":[]}]}}]}}}},"page":"/[slug]","query":{"slug":"file-upload-web-service-golang-s3-aws"},"buildId":"dU5p4h8CqmjB2C_JFQuti"}</script><script async="" data-next-page="/[slug]" src="/_next/static/dU5p4h8CqmjB2C_JFQuti/pages/%5Bslug%5D.js"></script><script async="" data-next-page="/_app" src="/_next/static/dU5p4h8CqmjB2C_JFQuti/pages/_app.js"></script><script src="/_next/static/runtime/webpack-4b444dab214c6491079c.js" async=""></script><script src="/_next/static/chunks/commons.921669d6706eeb20080a.js" async=""></script><script src="/_next/static/runtime/main-6e6e334c1a3c61df2d4f.js" async=""></script><script src="/_next/static/chunks/styles.19cd142641676dafa9ae.js" async=""></script></body></html>